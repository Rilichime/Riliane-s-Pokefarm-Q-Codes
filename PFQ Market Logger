// ==UserScript==
// @name         PFQ Market Logger Enhanced
// @version      2.4
// @description  Logs sold prices for items viewed in the market.
// @match        https://pokefarm.com/marketboard*
// @grant        none
// @icon         https://cdn-icons-png.flaticon.com/128/2422/2422792.png
// ==/UserScript==

(function() {
    'use strict';

    const DB_NAME = 'pfq_market_logger';
    const DB_VERSION = 1;
    const RUN_INTERVAL_MS = 3000;
    let db = null;

    const months = { Jan:0, Feb:1, Mar:2, Apr:3, May:4, Jun:5, Jul:6, Aug:7, Sep:8, Oct:9, Nov:10, Dec:11 };

    // IndexedDB wrapper functions
    async function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                db = request.result;
                resolve(db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                // Market entries store
                if (!db.objectStoreNames.contains('entries')) {
                    const entriesStore = db.createObjectStore('entries', { keyPath: 'id' });
                    entriesStore.createIndex('itemName', 'itemName', { unique: false });
                    entriesStore.createIndex('timestamp', 'ts', { unique: false });
                }

                // Settings store (UI state, ignored items, notes, scan times)
                if (!db.objectStoreNames.contains('settings')) {
                    db.createObjectStore('settings', { keyPath: 'key' });
                }
            };
        });
    }

    async function saveEntry(entry) {
        if (!db) await initDB();
        const tx = db.transaction(['entries'], 'readwrite');
        const store = tx.objectStore('entries');
        return store.put(entry);
    }

    async function getEntriesByItem(itemName) {
        if (!db) await initDB();
        const tx = db.transaction(['entries'], 'readonly');
        const store = tx.objectStore('entries');
        const index = store.index('itemName');

        return new Promise((resolve, reject) => {
            const request = index.getAll(itemName);
            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
        });
    }

    async function getAllEntries() {
        if (!db) await initDB();
        const tx = db.transaction(['entries'], 'readonly');
        const store = tx.objectStore('entries');

        return new Promise((resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
        });
    }

    async function getSetting(key, defaultValue = null) {
        if (!db) await initDB();
        const tx = db.transaction(['settings'], 'readonly');
        const store = tx.objectStore('settings');

        return new Promise((resolve, reject) => {
            const request = store.get(key);
            request.onsuccess = () => {
                const result = request.result;
                resolve(result ? result.value : defaultValue);
            };
            request.onerror = () => reject(request.error);
        });
    }

    async function setSetting(key, value) {
        if (!db) await initDB();
        const tx = db.transaction(['settings'], 'readwrite');
        const store = tx.objectStore('settings');
        return store.put({ key, value });
    }

    async function updateEntry(id, updates) {
        if (!db) await initDB();
        const tx = db.transaction(['entries'], 'readwrite');
        const store = tx.objectStore('entries');

        return new Promise((resolve, reject) => {
            const getRequest = store.get(id);
            getRequest.onsuccess = () => {
                const entry = getRequest.result;
                if (entry) {
                    Object.assign(entry, updates);
                    const putRequest = store.put(entry);
                    putRequest.onsuccess = () => resolve(entry);
                    putRequest.onerror = () => reject(putRequest.error);
                } else {
                    reject(new Error('Entry not found'));
                }
            };
            getRequest.onerror = () => reject(getRequest.error);
        });
    }

    // Utility functions
    function stableId(itemName, dateStr, user, price, qty) {
        return `${itemName}||${dateStr}||${price}||${qty}`;
    }

    function toNumber(txt) {
        return parseInt((txt||'').replace(/[^\d]/g,''))||0;
    }

    function parseQty(txt) {
        return parseInt((txt||'').replace(/[^\d]/g,''))||0;
    }

    function parseSoldDateToTS(dateStr) {
        const m = dateStr.trim().match(/^(\d{1,2})\/([A-Za-z]{3})\s+(\d{2}):(\d{2})$/);
        if(!m) return null;
        const day = parseInt(m[1],10), mon = months[m[2]], hour = parseInt(m[3],10), minute = parseInt(m[4],10);
        if(isNaN(mon)) return null;

        // Get current time in British timezone (UTC+0 or UTC+1 depending on DST)
        const now = new Date();
        const britishNow = new Date(now.toLocaleString("en-US", {timeZone: "Europe/London"}));
        let year = britishNow.getFullYear();

        // Create the date in British timezone
        let d = new Date(year, mon, day, hour, minute);

        // If the constructed date is more than 6 hours in the future compared to British time,
        // it's probably from the previous year
        if(d.getTime() > britishNow.getTime() + (6 * 60 * 60 * 1000)) {
            d = new Date(year-1, mon, day, hour, minute);
        }

        return d.getTime();
    }

    function fmtNumber(n) {
        if(n >= 1_000_000) return (Math.round(n/100_000)/10)+' mil';
        if(n >= 1_000) return Math.round(n/1_000)+' k';
        return n.toString();
    }

    function escapeHTML(s) {
        return (s||'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    function fmtElapsed(ts) {
        if(!ts) return "never";
        const diff = Math.floor((Date.now() - ts)/1000);
        const days = Math.floor(diff / 86400);

        if(diff < 86400) return "Today";
        if(days < 7) return `${days}d ago`;
        if(days < 30) {
            const weeks = Math.floor(days / 7);
            return `${weeks}w ago`;
        }
        const months = Math.floor(days / 30);
        return `${months}mo ago`;
    }

    function formatDisplayDate(ts) {
        if (!ts) return '';
        const date = new Date(ts);
        const year = date.getFullYear();
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                           'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const month = monthNames[date.getMonth()];
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');

        return `${year} ${month} ${day} ${hours}:${minutes}`;
    }

    function createPanel() {
        const panel = document.createElement('div');
        panel.id = 'pfq-market-logger-panel';
        Object.assign(panel.style, {
            position:'fixed', left:'4px', top:'30px', width:'1200px', height:'400px',
            overflow:'auto', zIndex:'100', background:'rgba(0,0,0,0.85)',
            color:'white', padding:'10px', fontSize:'14px', fontFamily:'sans-serif'
        });

        panel.innerHTML = `
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;">
            <strong id="pfq-ml-item-name" style="flex:1 1 auto; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Item: (detecting...)</strong>
            <button id="pfq-ml-run" style="cursor:pointer;">Run now</button>
            <button id="pfq-ml-export" style="cursor:pointer;">Export CSV</button>
            <button id="pfq-ml-upload" style="cursor:pointer;">Upload CSV</button>
            <button id="pfq-ml-clear" style="cursor:pointer; background:#d32f2f; color:white;">Clear Data</button>
            <button id="pfq-ml-hide" style="cursor:pointer;">Hide</button>
        </div>
        <canvas id="pfq-ml-canvas" width="1180" height="160" style="width:1180px;height:160px;background:rgba(255,255,255,0.06);border-radius:6px;"></canvas>
        <div id="pfq-ml-stats" style="margin:6px 0 10px 0; opacity:0.9;"></div>
        <table id="pfq-ml-table" style="width:100%;border-collapse:collapse;">
            <thead>
                <tr style="background:rgba(255,255,255,0.1);">
                    <th></th>
                    <th>Date</th>
                    <th>User</th>
                    <th>Price</th>
                    <th>Qty</th>
                    <th>Notes</th>
                    <th>Last Scan</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        `;
        document.body.appendChild(panel);

        const showBtn = document.createElement('button');
        showBtn.id = 'pfq-ml-show';
        showBtn.textContent = 'Show Price Tracker';
        Object.assign(showBtn.style, {
            position:'fixed',left:'4px',top:'30px',zIndex:'101',display:'none',cursor:'pointer'
        });
        document.body.appendChild(showBtn);

        // Event listeners
        showBtn.addEventListener('click', async () => {
            panel.style.display = '';
            showBtn.style.display = 'none';
            await setSetting('ui_hidden', false);
        });

        panel.querySelector('#pfq-ml-hide').addEventListener('click', async () => {
            panel.style.display = 'none';
            showBtn.style.display = '';
            await setSetting('ui_hidden', true);
        });

        panel.querySelector('#pfq-ml-run').addEventListener('click', runOnce);
        panel.querySelector('#pfq-ml-export').addEventListener('click', exportCSV);
        panel.querySelector('#pfq-ml-upload').addEventListener('click', uploadCSV);
        panel.querySelector('#pfq-ml-clear').addEventListener('click', clearAllData);

        // Initialize UI state
        getSetting('ui_hidden', false).then(hidden => {
            if(hidden) {
                panel.style.display = 'none';
                showBtn.style.display = '';
            }
        });

        return panel;
    }

    function getVisibleSellerLists() {
        return Array.from(document.querySelectorAll('ul.sellerlist')).filter(ul => ul.offsetParent !== null);
    }

    function findItemNameForSellerList(ul) {
        let container = ul.closest('li, .mb-item, .marketboard, div') || ul.parentElement;
        let nameSpan = container.querySelector('a span.name span.name') || container.querySelector('span.name span.name');
        if(!nameSpan) {
            const allNames = Array.from(document.querySelectorAll('a span.name span.name, span.name span.name'));
            nameSpan = allNames.find(sp => sp.offsetParent !== null);
        }
        return nameSpan?.textContent.trim() || null;
    }

    async function updateScannedDisplay(itemName) {
        if(!itemName) return;
        const scannedMap = await getSetting('scanned_times', {});
        const ts = scannedMap[itemName];
        const elapsed = fmtElapsed(ts);

        const nameSpans = document.querySelectorAll('.inventory > div > ul > li > span > .name');
        nameSpans.forEach(ns => {
            if(ns.textContent.trim() === itemName) {
                let sub = ns.parentElement.querySelector('.pfq-scanned-time');
                if(!sub) {
                    sub = document.createElement('div');
                    sub.className = 'pfq-scanned-time';
                    sub.style.fontSize = '10pt';
                    sub.style.color = 'var(--col-link2)';
                    sub.style.marginTop = '2px';
                    ns.appendChild(sub);
                }
                sub.textContent = `Scanned: ${elapsed}`;
            }
        });
    }

    async function updateAllScannedDisplays() {
        const scannedMap = await getSetting('scanned_times', {});
        const nameSpans = document.querySelectorAll('.inventory > div > ul > li > span > .name');
        nameSpans.forEach(ns => {
            const itemName = ns.textContent.trim();
            const ts = scannedMap[itemName];
            if(ts) {
                const elapsed = fmtElapsed(ts);
                let sub = ns.parentElement.querySelector('.pfq-scanned-time');
                if(!sub) {
                    sub = document.createElement('div');
                    sub.className = 'pfq-scanned-time';
                    sub.style.fontSize = '10pt';
                    sub.style.color = 'var(--col-link2)';
                    sub.style.marginTop = '2px';
                    ns.appendChild(sub);
                }
                sub.textContent = `Scanned: ${elapsed}`;
            }
        });
    }

    async function scrapeOnce() {
        const visibleLists = getVisibleSellerLists();
        const scannedMap = await getSetting('scanned_times', {});
        let firstDetectedItem = null;

        for(const ul of visibleLists) {
            const itemName = findItemNameForSellerList(ul);
            if(!itemName) continue;
            if(!firstDetectedItem) firstDetectedItem = itemName;

            scannedMap[itemName] = Date.now();

            const existingEntries = await getEntriesByItem(itemName);
            const existingIds = new Set(existingEntries.map(e => e.id));

            const rows = Array.from(ul.querySelectorAll('li')).filter(li => !li.classList.contains('th'));

            for(const li of rows) {
                const unitEl = li.querySelector('.unit');
                const qtyEl = li.querySelector('.q');
                const totalEl = li.querySelector('.total');
                if(!unitEl || !qtyEl || !totalEl) continue;

                const priceEach = toNumber(unitEl.textContent);
                const qty = parseQty(qtyEl.textContent);
                const dateText = (totalEl.innerHTML.split('<br>')[0] || totalEl.textContent).replace(/<[^>]*>/g,'').trim();
                const afterBr = totalEl.innerHTML.split('<br>')[1] || '';
                const user = afterBr.replace(/to\s*/i,'').replace(/<[^>]*>/g,'').trim() || '';
                const dateStr = dateText;
                const ts = parseSoldDateToTS(dateStr);
                if(!ts) continue;

                const id = stableId(itemName, dateStr, user, priceEach, qty);
                if(existingIds.has(id)) continue;

                const entry = {
                    id,
                    itemName,
                    ts,
                    dateStr,
                    user,
                    price: priceEach,
                    qty,
                    ignored: false,
                    note: '',
                    lastScan: Date.now()
                };

                await saveEntry(entry);
            }
        }

        await setSetting('scanned_times', scannedMap);

        if(firstDetectedItem) {
            await setSetting('last_item', firstDetectedItem);
            await updateScannedDisplay(firstDetectedItem);
        }

        return firstDetectedItem;
    }

    async function renderPanel() {
        const panel = document.getElementById('pfq-market-logger-panel');
        if(!panel) return;

        const scrollTop = panel.scrollTop;

        let itemName = await getSetting('last_item', '');
        if(!itemName) {
            itemName = await scrapeOnce() || '(no item detected yet)';
            await setSetting('last_item', itemName);
        }

        panel.querySelector('#pfq-ml-item-name').textContent = `Item: ${itemName}`;
        await updateScannedDisplay(itemName);

        const tbody = panel.querySelector('#pfq-ml-table tbody');
        tbody.innerHTML = '';

        const allEntries = await getEntriesByItem(itemName);
        allEntries.sort((a,b) => b.ts - a.ts);

        for(const e of allEntries) {
            const tr = document.createElement('tr');

            tr.innerHTML = `
                <td style="padding:4px; border-bottom:1px solid rgba(255,255,255,0.1);">
                    <input type="checkbox" ${e.ignored?'checked':''} data-id="${e.id}" />
                </td>
                <td style="padding:4px; border-bottom:1px solid rgba(255,255,255,0.1);">${formatDisplayDate(e.ts)}</td>
                <td style="padding:4px; border-bottom:1px solid rgba(255,255,255,0.1);">${escapeHTML(e.user)}</td>
                <td style="padding:4px; text-align:right; border-bottom:1px solid rgba(255,255,255,0.1);">${fmtNumber(e.price)}</td>
                <td style="padding:4px; text-align:right; border-bottom:1px solid rgba(255,255,255,0.1);">${e.qty}</td>
                <td style="padding:4px; border-bottom:1px solid rgba(255,255,255,0.1); width:200px;">
                    <input type="text" class="note-input" data-id="${e.id}" value="${escapeHTML(e.note||'')}"
                           style="width:100%;background:rgba(255,255,255,0.1);color:white;border:none;padding:2px;" />
                </td>
                <td style="padding:4px; border-bottom:1px solid rgba(255,255,255,0.1);">${fmtElapsed(e.lastScan)}</td>
            `;

            tbody.appendChild(tr);
        }

        // Checkbox toggle
        tbody.querySelectorAll('input[type=checkbox]').forEach(cb => {
            cb.addEventListener('change', async () => {
                const id = cb.dataset.id;
                await updateEntry(id, { ignored: cb.checked });
            });
        });

        // Notes update
        tbody.querySelectorAll('.note-input').forEach(inp => {
            inp.addEventListener('change', async () => {
                const id = inp.dataset.id;
                await updateEntry(id, { note: inp.value });
            });
        });

        // Stats
        const validEntries = allEntries.filter(e => !e.ignored);
        const prices = validEntries.map(e => e.price);
        const avg = prices.reduce((a,b)=>a+b,0)/ (prices.length||1);
        const median = (() => {
            if(prices.length === 0) return 0;
            const sorted = [...prices].sort((a,b)=>a-b);
            const mid = Math.floor(sorted.length/2);
            return sorted.length%2?sorted[mid]:(sorted[mid-1]+sorted[mid])/2;
        })();
        const statsDiv = panel.querySelector('#pfq-ml-stats');
        statsDiv.innerHTML = `
            <div><strong>Stats:</strong> ${validEntries.length} records | Avg: ${fmtNumber(Math.round(avg))} | Median: ${fmtNumber(Math.round(median))}</div>
        `;

        // Draw chart
        drawChart(panel.querySelector('#pfq-ml-canvas'), validEntries);

        panel.scrollTop = scrollTop;
    }

    function drawChart(canvas, entries) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width,canvas.height);

        if(entries.length < 2) return;

        const minTs = Math.min(...entries.map(e=>e.ts));
        const maxTs = Math.max(...entries.map(e=>e.ts));
        const minPrice = Math.min(...entries.map(e=>e.price));
        const maxPrice = Math.max(...entries.map(e=>e.price));

        const margin = 20;
        const plotWidth = canvas.width - margin*2;
        const plotHeight = canvas.height - margin*2;

        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.rect(margin, margin, plotWidth, plotHeight);
        ctx.stroke();

        const xs = ts => margin + ( (ts - minTs) / (maxTs - minTs) ) * plotWidth;
        const ys = p => margin + plotHeight - ( (p - minPrice) / (maxPrice - minPrice) ) * plotHeight;

        ctx.beginPath();
        ctx.strokeStyle = '#4fc3f7';
        ctx.lineWidth = 2;
        entries.forEach((e,i)=>{
            if(i===0) ctx.moveTo(xs(e.ts), ys(e.price));
            else ctx.lineTo(xs(e.ts), ys(e.price));
        });
        ctx.stroke();
    }

    async function runOnce() {
        await scrapeOnce();
        await renderPanel();
    }

    async function exportCSV() {
        const all = await getAllEntries();
        const lines = ['Item,Date,User,Price,Qty,Ignored,Note,LastScan'];

        all.forEach(e=>{
            const line = [
                `"${e.itemName}"`,
                `"${formatDisplayDate(e.ts)}"`,
                `"${e.user}"`,
                e.price,
                e.qty,
                e.ignored,
                `"${(e.note||'').replace(/"/g,'""')}"`,
                `"${formatDisplayDate(e.lastScan)}"`
            ].join(',');
            lines.push(line);
        });

        const blob = new Blob([lines.join('\n')], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pfq_market_data.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
    }

    async function uploadCSV() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.csv';

        input.addEventListener('change', async () => {
            const file = input.files[0];
            if(!file) return;
            const text = await file.text();
            const lines = text.split(/\r?\n/).slice(1);

            for(const line of lines) {
                if(!line.trim()) continue;
                const parts = line.split(',');
                const itemName = parts[0].replace(/^"|"$/g,'');
                const dateStr = parts[1].replace(/^"|"$/g,'');
                const user = parts[2].replace(/^"|"$/g,'');
                const price = parseInt(parts[3],10);
                const qty = parseInt(parts[4],10);
                const ignored = parts[5] === 'true';
                const note = parts[6].replace(/^"|"$/g,'');
                const lastScanStr = parts[7].replace(/^"|"$/g,'');
                const ts = new Date(dateStr).getTime();
                const lastScan = new Date(lastScanStr).getTime();

                const id = stableId(itemName, dateStr, user, price, qty);
                const entry = { id, itemName, ts, dateStr, user, price, qty, ignored, note, lastScan };
                await saveEntry(entry);
            }

            await renderPanel();
        });

        input.click();
    }

    async function clearAllData() {
        if(!db) await initDB();

        if(!confirm('Are you sure you want to clear all stored market data? This cannot be undone.')) return;

        const tx1 = db.transaction(['entries'], 'readwrite');
        tx1.objectStore('entries').clear();

        const tx2 = db.transaction(['settings'], 'readwrite');
        tx2.objectStore('settings').clear();

        await renderPanel();
    }

    async function main() {
        await initDB();
        createPanel();
        await renderPanel();
        await updateAllScannedDisplays();

        setInterval(runOnce, RUN_INTERVAL_MS);
    }

    main();
})();
